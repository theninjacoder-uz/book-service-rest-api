package models

import (
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"os"
	"strconv"
	"strings"
	"time"

	"gorm.io/gorm"
)

type Book struct {
	ID        uint64    `json:"id" gorm:"primary_key:auto_increment"`
	Isbn      string    `json:"isbn" gorm:"type:varchar(255);not null;uniqueIndex;unique"`
	Title     string    `json:"title" gorm:"type:varchar(255)"`
	Author    string    `json:"author" gorm:"type:varchar(255)"`
	Published uint32    `json:"published"`
	Pages     uint32    `json:"pages"`
	Status    uint32    `json:"-"`
	CreatedAt time.Time `json:"-"`
	UpdatedAt time.Time `json:"-"`
}

type OenLibData struct {
	Title   string `json:"title"`
	Authors []struct {
		Name string `json:"name"`
	}
	PablishDate   string `json:"publish_date"`
	NumberOfPages uint32 `json:"number_of_pages"`
}

type Info map[string]OenLibData

type BookDto struct {
	Book   Book   `json:"book"`
	Status uint32 `json:"status"`
}

func (b *Book) Prepare(data OenLibData) {
	b.ID = 0 // Id generated by database
	b.Isbn = strings.TrimSpace(b.Isbn)
	b.Author = data.Authors[0].Name
	b.Title = data.Title
	// openapilib data saves year in string format like: "October 1 2022" so grab only years
	// if year < 1000 or year > 10000 then error occurs. Possible bug should be fixed :(
	year, _ := strconv.ParseInt(data.PablishDate[len(data.PablishDate)-4:], 10, 32)
	b.Published = uint32(year)
	b.Pages = data.NumberOfPages
	b.CreatedAt = time.Now()
	b.UpdatedAt = b.CreatedAt
	b.Status = 0 //when create book, status should  be 0 meaning "new"
}

// check incoming request body before working on it
func (b *Book) Validate(action string) error {

	switch strings.ToLower(action) {
	case "create":
		if b.Isbn == "" {
			return errors.New("required isbn")
		}
	case "update":
		if b.Isbn == "" {
			return errors.New("required isbn")
		} else if b.Title == "" {
			return errors.New("required title")
		} else if b.Author == "" {
			return errors.New("required author")
		} else if b.Status > 2 {
			return errors.New("book status is not valid")
		}
	}
	return nil
}

func (b *Book) SaveABook(db *gorm.DB) (*BookDto, error) {

	//Check whether book with isbn exists in our database if so just return it
	data, err := b.FindABookByIsbn(db, b.Isbn)
	if err == nil {
		return &BookDto{Book: *data, Status: data.Status}, nil
	}

	// else get book info from external api
	openLibraryUri := fmt.Sprintf(os.Getenv("OPEN_LIBRARY_API"), b.Isbn)
	res, err := http.Get(openLibraryUri)

	if err != nil {
		return &BookDto{}, err
	}
	defer res.Body.Close()
	var info Info

	body, err := io.ReadAll(res.Body)
	if err != nil {
		return &BookDto{}, err
	}

	err = json.Unmarshal(body, &info)

	if err != nil {
		return &BookDto{}, err
	}

	//format fetching data
	b.Prepare(info["ISBN:"+b.Isbn])

	//save a book to database
	db = db.Debug().Model(&Book{}).Create(&b)
	if db.Error != nil {
		return &BookDto{}, db.Error
	}

	return &BookDto{Book: *b, Status: b.Status}, nil
}

func (b *Book) FindAllBooks(db *gorm.DB) (*[]BookDto, error) {
	books := []Book{}
	db = db.Debug().Model(&Book{}).Limit(100).Find(&books)
	if db.Error != nil {
		return &[]BookDto{}, db.Error
	}
	// convert book infos to bookdto
	bookDtos := []BookDto{}

	for _, b := range books {
		bookDtos = append(bookDtos, BookDto{Book: b, Status: b.Status})
	}

	return &bookDtos, nil
}

func (b *Book) UpdateABook(db *gorm.DB, id uint64) (*BookDto, error) {

	err := db.Debug().Model(&Book{}).Where("id = ?", id).Updates(Book{Isbn: b.Isbn, Title: b.Title, Author: b.Author, Published: b.Published, Pages: b.Pages, Status: b.Status, UpdatedAt: time.Now()}).Error

	if err != nil {
		return &BookDto{}, fmt.Errorf("record not found with id: %v", id)
	}
	b.ID = id
	return &BookDto{Book: *b, Status: b.Status}, nil
}

func (b *Book) DeleteABook(db *gorm.DB, id uint64) (int64, error) {
	db = db.Debug().Model(&Book{}).Where("id = ?", id).Take(&Book{}).Delete(&Book{})
	if db.Error != nil {
		return 0, fmt.Errorf("record not found with id: %v", id)
	}
	return db.RowsAffected, nil
}

func (b *Book) FindABookByIsbn(db *gorm.DB, isbn string) (*Book, error) {
	err := db.Debug().Model(&Book{}).Where("isbn = ?", isbn).Take(&b).Error
	if err != nil {
		return &Book{}, fmt.Errorf("record not found with isbn: %v", isbn)
	}
	return b, nil
}
